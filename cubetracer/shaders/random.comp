#define GLUS_PI 3.1415926535897932384626433832795

float radicalInverse_VdC(uint bits) {
 bits = (bits << 16u) | (bits >> 16u);
 bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
 bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
 bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
 bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
 return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 hammersley(uint i) {
 return vec2(float(i)*(1.0/512.0), radicalInverse_VdC(i));
}

// see Physically Based Rendering Chapter 13.6.1 and 13.6.3
vec3 cosineWeightedSampling(vec2 e) {
    float x = sqrt(1.0 - e.x) * cos(2.0*GLUS_PI*e.y);
    float y = sqrt(1.0 - e.x) * sin(2.0*GLUS_PI*e.y);
    float z = sqrt(e.x);

    return vec3(x, y, z);
}

// see http://www.scratchapixel.com/lessons/3d-advanced-lessons/things-to-know-about-the-cg-lighting-pipeline/what-is-a-brdf/
// see Physically Based Rendering Chapter 5.6.1, 13.2 and 13.6.3
// see Fundamentals of Computer Graphics Chapter 14.2 and 24.2
vec3 brdfLambert(vec2 randomPoint, mat3 basis) {
    vec3 LtangentSpace = cosineWeightedSampling(randomPoint);

    // Transform light ray to world space.
    return basis * LtangentSpace;
}

vec3 random_ray(int sampleIndex, vec3 normal) {
    vec3 tangent;

    if (abs(dot(normal, vec3(0.0, 1.0, 0.0))) < 1e-3)
        tangent = cross(normal, vec3(0.0, 0.0, 1.0));
    else
        tangent = cross(normal, vec3(0.0, 1.0, 0.0));

    vec3 bitangent = cross(normal, tangent);

    return brdfLambert(hammersley(sampleIndex), mat3(tangent, bitangent, normal));
}

