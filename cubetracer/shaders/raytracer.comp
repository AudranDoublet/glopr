#version 430 core
// FIXME: We should implement an `#include` system to split this code into multiple sources

// FIXME: Should be configurable before compilation instead of being hardcoded
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* ************************************************************
 * > --1- Constants
 * ************************************************************/
const bool CST_SHADOW_ACTIVATED = <<<CST_SHADOW_ACTIVATED>>>;

const float CST_EPSILON = 1e-4;
const uint CST_CHUNK_WIDTH = 16;
const uint CST_CHUNK_HEIGHT = 256;
const vec3 CST_LOCAL_TO_WORLD = vec3(CST_CHUNK_WIDTH);
const vec3 CST_WORLD_TO_LOCAL = 1 / CST_LOCAL_TO_WORLD;
const vec3 CST_BLOCK_COLORS[] = {
    vec3(1, 1, 0),
    vec3(0, 0, 1),
    vec3(0.2, 0.2, 0.2),
    vec3(0, 1, 0),
    vec3(0.7, 0.6, 0.),
    vec3(0.4, 0.4, 0.4),

    vec3(0.8, 0.6, 0.3),
    vec3(0, 0.9, 0),
    vec3(0.9),
    vec3(0, 0.6, 0.1),
};

const uint CST_VIEW_DISTANCE = <<<CST_VIEW_DISTANCE>>>;
const uint CST_NB_CHUNKS_X = (2*CST_VIEW_DISTANCE);
const uint CST_NB_CHUNKS_XZ = CST_NB_CHUNKS_X * CST_NB_CHUNKS_X;

const vec3 CST_LIGHT_DIRECTION = normalize(vec3(-0.7, -1.5, -1.1));
const vec3 CST_LIGHT_DIRECTION_INV = 1 / CST_LIGHT_DIRECTION;
const vec3 CST_LIGHT_AMBIENT = vec3(0.15, 0.3, 0.2);

const vec3 CST_NORMAL_MAP[6] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1),
    vec3(-1, 0, 0),
    vec3(0, -1, 0),
    vec3(0, 0, -1),
};

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 direction_inv;
};

struct Material {
    int type;
    int texture_coords[6];
};

#define TEX_UNIQUE(v) (v), (v), (v), (v), (v), (v)
#define TEX_COLUMN(v, w, z) (v), (w), (v), (v), (z), (v)
#define MATERIAL_EMPTY() Material(0, int[6]( TEX_UNIQUE(0) ))
#define MATERIAL_U(u) Material(1, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_U_NO_NORM(u) Material(2, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_C(v, w, z) Material(1, int[6]( TEX_COLUMN(v, w, z) ))
#define MATERIAL_LOG(i) MATERIAL_C(LOGS_TEX + i*2, TOP_LOGS_TEX + i*2, TOP_LOGS_TEX + i*2)
#define MATERIAL_LEAVES(i) MATERIAL_U_NO_NORM(LEAVES_TEX + i)

#define STONE_TEX       0
#define DIRT_TEX        2
#define GRASS_TOP_TEX   4
#define GRASS_SIDE_TEX  6
#define SAND_TEX        8
#define SNOW_TEX        10
#define GRAVEL_TEX      12
#define CACTUS_TOP_TEX  14
#define CACTUS_SIDE_TEX 16
#define CACTUS_BOTT_TEX 18
#define LOGS_TEX        20
#define TOP_LOGS_TEX    32
#define LEAVES_TEX      44

const Material CST_BLOCK_MATERIALS[] = {
    MATERIAL_EMPTY(),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),                                          // Stone
    MATERIAL_C(GRASS_SIDE_TEX, GRASS_TOP_TEX, DIRT_TEX),            // Grass
    MATERIAL_U(DIRT_TEX),                                           // Dirt
    MATERIAL_U(GRAVEL_TEX),                                         // Gravel
    MATERIAL_U(SAND_TEX),                                           // Sand
    MATERIAL_C(CACTUS_SIDE_TEX, CACTUS_TOP_TEX, CACTUS_BOTT_TEX),   // Cactus
    MATERIAL_U(SNOW_TEX),                                           // Snow
    MATERIAL_U(STONE_TEX),
    MATERIAL_LOG(0),
    MATERIAL_LOG(1),
    MATERIAL_LOG(2),
    MATERIAL_LOG(3),
    MATERIAL_LOG(4),
    MATERIAL_LOG(5),
    MATERIAL_LEAVES(0),
    MATERIAL_LEAVES(1),
    MATERIAL_LEAVES(2),
    MATERIAL_LEAVES(3),
    MATERIAL_LEAVES(4),
    MATERIAL_LEAVES(5),
};

/* ************************************************************
 * > -1- Variables
 * ************************************************************/
    /* > -A- Inputs */
layout (std430) readonly buffer shader_data {
    uint cl_filled[CST_NB_CHUNKS_XZ][16];
    uint cl_blocks[CST_NB_CHUNKS_XZ][CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
};

uniform VirtualScreen in_uni_screen;
uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform sampler2DArray in_uni_textures;

    /* > -B- Outputs */
layout (binding = 0, rgba32f) uniform image2D out_uni_frame;

    /* > -C- Global Variables */

/* ************************************************************
 * > -2- Helpers (abr: "h")
 * ************************************************************/
    /* > -A- Float Operations (abr: "f") */
float h_f_inv_safe(float v) {
    return v == 0.0 ? 1e15 : (1 / v);
}
    /* > -B- Vector Operations (abr: "v") */
float h_v_component_min(vec3 v) {
    return min(min(v.x, v.y), v.z); 
}
float h_v_component_max(vec3 v) {
    return max(max(v.x, v.y), v.z); 
}
vec3 h_v_inv_safe(vec3 v) {
    return vec3(h_f_inv_safe(v.x), h_f_inv_safe(v.y), h_f_inv_safe(v.z));
}
vec3 h_v_inv(vec3 v) {
    // WANING: this entirely rely on GLSL 4.30 (see: 4.7.1 Range and Precision)
    // https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.30.pdf
    // We have the guarantee that a division will lead to (+/-)Inf, which is
    // OK for the usages here and should be slightly faster than the safe
    // version.

    return vec3(1) / v;
}

    /* > -C Array Operations (abr: "a") */
uint h_a_2d_to_1d(ivec2 coords, uint width) {
    return coords.x + coords.y * width;
}
uint h_a_3d_to_1d(ivec3 coords, uint width, uint height) {
    return coords.x + (coords.y + coords.z * height) * width;
}


/* ************************************************************
 * > -3- Section: Ray (abr: "ray")
 * ************************************************************/

vec3 ray_direction(vec2 pixel) {
    return normalize(in_uni_screen.top_left 
        - pixel.x * in_uni_screen.left
        - pixel.y * in_uni_screen.up);
}

Ray ray_make(vec2 pixel) {
    vec3 origin = in_uni_origin - vec3(in_uni_cl_min_coords.x, 0, in_uni_cl_min_coords.y) * CST_LOCAL_TO_WORLD;
    vec3 r_dir = ray_direction(pixel);
    vec3 r_dir_inv = h_v_inv(r_dir);

    return Ray(origin, r_dir, r_dir_inv);
}

/* ************************************************************
 * > -3- Section: Textures
 * ************************************************************/

vec2 bbox_uv(const vec3 boxMin, const vec3 boxMax, const vec3 diff, const vec3 intersection, int face) {
    if (face == 0 || face == 3) {
        return vec2((intersection.z - boxMin.z) / diff.z, 1 - (intersection.y - boxMin.y) / diff.y);
    }

    if (face == 1 || face == 4) {
        return vec2((intersection.x - boxMin.x) / diff.x, (intersection.z - boxMin.z) / diff.z);
    }

    return vec2((intersection.x - boxMin.x) / diff.x, 1 - (intersection.y - boxMin.y) / diff.y);
}

vec2 texture_coords(ivec2 pos, vec2 uv) {
    vec2 size = vec2(1.0 / 8, 1.0 / 8); // FIXME remove hardcoded width/height

    return vec2(float(pos.x) * size.x, float(pos.y) * size.y) + uv * size;
}

vec4 texture_color(int tex, vec2 uv, float t) {
    return textureLod(in_uni_textures, vec3(uv.x, uv.y, float(tex)), t);
}

vec3 texture_normal(int texture, vec3 normal, vec2 uv, int face, float t) {
    vec3 tangeant;

    if (face == 2 || face == 5)
        tangeant = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    else
        tangeant = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));

    vec3 b = normalize(cross(normal, tangeant));
    vec4 color = textureLod(in_uni_textures, vec3(uv.x, uv.y, float(texture + 1)), t);
    vec3 map_normal = color.xyz * 2 - vec3(1);

    //FIXME mat3 could be precomputed for face
    return mat3(tangeant, b, normal) * map_normal;
}

/* ************************************************************
 * > -4- Section: Chunks/Blocks memory fetching
 * ************************************************************/
    /* > -A- Chunks */
bool bl_is_inside(ivec3 block) {
    return block.x >= 0 && block.x < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH
        && block.y >= 0 && block.y < CST_CHUNK_HEIGHT
        && block.z >= 0 && block.z < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH;
}

    /* > -B- Blocks */
uint bl_value(ivec2 chunk, ivec3 block) {
    // FIXME: not sure :[
    block -= ivec3(chunk.x, 0, chunk.y) * ivec3(CST_LOCAL_TO_WORLD);
    // FIXME-END

    return cl_blocks
        [h_a_2d_to_1d(chunk, CST_NB_CHUNKS_X)]
        [block.x + (block.z + block.y * CST_CHUNK_WIDTH) * CST_CHUNK_WIDTH];
}


/* ************************************************************
 * > -6- Section: Ray Tracer
 * ************************************************************/

vec4 sky_color(Ray r) {
    /*
    //vec3 color = vec3(0);
    vec3 color = (cos(r.direction*1.5) + sin(r.origin/7) + vec3(2))/4;
    return vec4(color, 1);
    */

    vec3 color = vec3(0.149, 0.6471, 0.7961);
    float coeff = abs(dot(r.direction, vec3(0, 1, 0))) * 0.2 + 0.8;
    return vec4(color * coeff, 1);
}

float BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    vec2 t = max(tmin.xx, tmin.yz);
    return max(t.x, t.y);
}

bool BBoxRayIntersects(const vec3 boxMin, const vec3 boxMax, const Ray r, out int face, out float t) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    ivec3 faces = ivec3(0, 1, 2) + ivec3(3) * ivec3(lessThan(tbot, ttop));

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    float t1 = tmin.x;
    face = faces.x;

    if (tmin.y > t1)
    {
        t1 = tmin.y;
        face = faces.y;
    }

    if (tmin.z > t1)
    {
        t1 = tmin.z;
        face = faces.z;
    }

    float t2 = min(min(tmax.x, tmax.y), tmax.z);

    if (t1 < t2) {
        t = t1;
        return true;
    }

    return false;
}

#define DRAW_RAY(R, MAX_ITER, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 block = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 _side_dist = (_sgn * (block - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    vec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && bl_is_inside(block); _i++) {\
        ivec3 chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
        uint block_type = bl_value(chunk.xz, block);\
        if (block_type != 0) {\
            {BOCK;}\
        }\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
    }


#define DRAW_RAY_WITH_CHUNK_OPTI(R, MAX_ITER, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 block = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 _side_dist = (_sgn * (block - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    vec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && bl_is_inside(block); _i++) {\
        ivec3 chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
        uint block_type = bl_value(chunk.xz, block);\
        if (block_type != 0) {\
            {BOCK;}\
        }\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
    }
/*
#define DRAW_RAY_WITH_CHUNK_OPTI(R, MAX_ITER, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 block = ivec3(floor(R.origin));\
    ivec3 chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 _side_dist = (_sgn * (block - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    // FIXME: dt_chunk = ivec3(CST_LOCAL_TO_WORLD) - dist_to_next_chunk;\
    ivec3 dt_chunk = ivec3(CST_LOCAL_TO_WORLD);\
    // FIXME-END\
    vec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && bl_is_inside(block); _i++) {\
        uint block_type = bl_value(chunk.xz, block);\
        if (block_type != 0) {\
            {BOCK;}\
        }\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
        dt_chunk += ivec3(_mask);\
        ivec3 chunk_overflow = ivec3(vec3(lessThan(dt_chunk, CST_LOCAL_TO_WORLD)));\
        chunk += (1 - chunk_overflow);\
        dt_chunk = dt_chunk * chunk_overflow;\
    }
*/

float distance_before_next_intersection(Ray ray) {
    DRAW_RAY(ray, CST_NB_CHUNKS_X, {
        return 0.;
    });
    return 1000.;
}

vec4 lighting(vec4 color, vec3 intersection, vec3 normal) {
    intersection += normal * CST_EPSILON;

    Ray shadow_ray = Ray(intersection, -CST_LIGHT_DIRECTION, -CST_LIGHT_DIRECTION_INV);

    vec3 light_diffuse = CST_LIGHT_AMBIENT;

    if (!CST_SHADOW_ACTIVATED || distance_before_next_intersection(shadow_ray) >= 1000.) {
        light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));
    }

    return vec4(light_diffuse, 1) * color;
}


vec4 cast_ray(Ray ray) {
    DRAW_RAY(ray, uint(-1), {
        vec3 min_pos = block;
        vec3 max_pos = min_pos;
        vec3 max_pos_offset = vec3(1);

        if (block_type == 1) { // water
            max_pos_offset = vec3(1, 0.9, 1);
        } else if (block_type == 8) { // snow
            max_pos_offset = vec3(1, 0.1, 1);
        }

        max_pos += max_pos_offset;

        int face = 0;
        float t;

        if (BBoxRayIntersects(min_pos, max_pos, ray, face, t)) {
            vec3 intersection = ray.origin + ray.direction * t;

            vec2 uv = bbox_uv(min_pos, max_pos, max_pos_offset, intersection, face);
            if (block.y == in_uni_highlighted_block.y && block.xz == (in_uni_highlighted_block.xz - in_uni_cl_min_coords * CST_LOCAL_TO_WORLD.xz) && (uv.x < 0.005 || uv.x > 0.995 || uv.y < 0.005 || uv.y > 0.995))
                return vec4(0.5, 0.5, 0.5, 1);

            int tex = CST_BLOCK_MATERIALS[block_type].texture_coords[face];
            float t_qual = t / 10;

            vec3 normal = CST_NORMAL_MAP[face];

            if (CST_BLOCK_MATERIALS[block_type].type == 1)
                normal = texture_normal(tex, normal, uv, face, t_qual);

            vec4 color = texture_color(tex, uv, t_qual);

            intersection += vec3(1) - max_pos_offset;

            if (color.w > 0.5)
                return lighting(color, intersection, normal);
        }
    });

    return sky_color(ray);
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    Ray ray = ray_make(vec2(pixel));

    vec4 color = cast_ray(ray);

    imageStore(out_uni_frame, pixel, color);
}
