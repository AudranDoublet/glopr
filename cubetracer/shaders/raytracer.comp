#version 430 core

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

/* ************************************************************
 * > -1- Inputs
 * ************************************************************/

uniform VirtualScreen in_uni_screen;
uniform int in_uni_iteration_id;

uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform vec3 in_uni_wind;
uniform float in_uni_time;

uniform sampler2DArray in_uni_textures;

/* ************************************************************
 * > -3- Includes
 * ************************************************************/

// 44
#include cubetracer/shaders/hyperparameters.comp
// 101
#include cubetracer/shaders/block_data.comp
// 25
#include cubetracer/shaders/ray.comp
// 131
#include cubetracer/shaders/block_intersection.comp

/* ************************************************************
 * > -4- Data
 * ************************************************************/

struct ChunkData {
    uint blocks[CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
    float grass_color[CST_CHUNK_WIDTH*CST_CHUNK_WIDTH][3];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (std430) readonly buffer shader_data {
    uint cl_chunks_mapping[CST_NB_CHUNKS_XZ];
    ChunkData cl_blocks[CST_NB_CHUNKS_XZ];
};

layout (binding = 0, rgba32f) uniform image2D out_uni_frame;
layout (binding = 1, rgba32f) uniform image2D cache_intersections;
layout (binding = 2, rgba32f) uniform image2D cache_normals;

/* ************************************************************
 * > -5- main
 * ************************************************************/

#include cubetracer/shaders/ray_casting.comp
#include cubetracer/shaders/lightning.comp

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    const Ray ray = ray_make_from_pixel(vec2(pixel));
    vec3 color;

    if (in_uni_iteration_id == 0) {
        mat3 pixelDirectIllumInfo = trace_ray_direct_illumination(ray);

        color = pixelDirectIllumInfo[0];
        imageStore(cache_intersections, pixel, vec4(pixelDirectIllumInfo[1], 1));
        imageStore(cache_normals, pixel, vec4(pixelDirectIllumInfo[2], 1));
    } else {
        vec3 normal = imageLoad(cache_normals, pixel).xyz;
        vec3 intersection = imageLoad(cache_intersections, pixel).xyz;

        vec3 pixelIndirectIllumSample = trace_ray_indirect_illumination(intersection, normal);

        // FIXME: the direct illum color must not be influenced by the sampling -> we need another cache
        color = imageLoad(out_uni_frame, pixel).rgb * float(in_uni_iteration_id);
        color = (color + pixelIndirectIllumSample) / (in_uni_iteration_id + 1);
        // FIXME-END
    }

    imageStore(out_uni_frame, pixel, vec4(color, 1));
}

