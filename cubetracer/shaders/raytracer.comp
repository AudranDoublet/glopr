#version 430 core

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

/* ************************************************************
 * > -1- Inputs
 * ************************************************************/

uniform VirtualScreen in_uni_screen;
uniform int in_uni_iteration_id;

uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform vec3 in_uni_wind;
uniform float in_uni_time;

uniform sampler2DArray in_uni_textures;

/* ************************************************************
 * > -3- Includes
 * ************************************************************/

// 44
#include cubetracer/shaders/hyperparameters.comp
// 101
#include cubetracer/shaders/block_data.comp
// 25
#include cubetracer/shaders/ray.comp
// 131
#include cubetracer/shaders/block_intersection.comp

/* ************************************************************
 * > -4- Data
 * ************************************************************/

struct ChunkData {
    uint blocks[CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
    float grass_color[CST_CHUNK_WIDTH*CST_CHUNK_WIDTH][3];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (std430) readonly buffer shader_data {
    uint cl_chunks_mapping[CST_NB_CHUNKS_XZ];
    ChunkData cl_blocks[CST_NB_CHUNKS_XZ];
};

layout (binding = 0, rgba32f) uniform image2D out_uni_frame;
layout (binding = 1, rgba32f) uniform image2D cache_illum_direct;
layout (binding = 2, rgba32f) uniform image2D cache_illum_indirect_sampling;
layout (binding = 3, rgba32f) uniform image2D cache_intersections;
layout (binding = 4, rgba32f) uniform image2D cache_normals;

/* ************************************************************
 * > -5- main
 * ************************************************************/

#include cubetracer/shaders/ray_casting.comp
#include cubetracer/shaders/lightning.comp

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    const Ray ray = ray_make_from_pixel(vec2(pixel));

    vec3 outColor = vec3(0);

    if (in_uni_iteration_id == 0) {
        mat3 pixelDirectIllumInfo = trace_ray_direct_illumination(ray);

        outColor = pixelDirectIllumInfo[0];

        imageStore(cache_illum_direct, pixel, vec4(pixelDirectIllumInfo[0], 1));
        imageStore(cache_intersections, pixel, vec4(pixelDirectIllumInfo[1], 1));
        imageStore(cache_normals, pixel, vec4(pixelDirectIllumInfo[2], 1));
    } else {
        vec3 normal = imageLoad(cache_normals, pixel).xyz;
        // check if initial ray has hit the sky
        if (normal == vec3(0)) {
            // FIXME: free compute time => can be used to sample more rays for another pixel?
            return;
        }
        vec3 intersection = imageLoad(cache_intersections, pixel).xyz;

        vec3 illum_sampling;
        if (in_uni_iteration_id == 1) {
            illum_sampling = vec3(0);
        } else {
            illum_sampling = imageLoad(cache_illum_indirect_sampling, pixel).rgb;
        }
        illum_sampling += trace_ray_indirect_illumination(intersection, normal);

        imageStore(cache_illum_indirect_sampling, pixel, vec4(illum_sampling, 1));
        outColor = imageLoad(cache_illum_direct, pixel).rgb + (illum_sampling / in_uni_iteration_id);
    }

    imageStore(out_uni_frame, pixel, vec4(outColor, 1));
}

