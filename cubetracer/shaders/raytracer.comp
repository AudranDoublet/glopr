#version 430 core
// FIXME: We should implement an `#include` system to split this code into multiple sources

// FIXME: Should be configurable before compilation instead of being hardcoded
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* ************************************************************
 * > --1- Constants
 * ************************************************************/
const bool CST_SHADOW_ACTIVATED = <<<CST_SHADOW_ACTIVATED>>>;

const float CST_EPSILON = 1e-4;
const uint CST_CHUNK_WIDTH = 16;
const uint CST_CHUNK_HEIGHT = 256;
const vec3 CST_LOCAL_TO_WORLD = vec3(CST_CHUNK_WIDTH);
const vec3 CST_WORLD_TO_LOCAL = 1 / CST_LOCAL_TO_WORLD;
const vec3 CST_BLOCK_COLORS[] = {
    vec3(1, 1, 0),
    vec3(0, 0, 1),
    vec3(0.2, 0.2, 0.2),
    vec3(0, 1, 0),
    vec3(0.7, 0.6, 0.),
    vec3(0.4, 0.4, 0.4),

    vec3(0.8, 0.6, 0.3),
    vec3(0, 0.9, 0),
    vec3(0.9),
    vec3(0, 0.6, 0.1),
};

const uint CST_VIEW_DISTANCE = <<<CST_VIEW_DISTANCE>>>;
const uint CST_NB_CHUNKS_X = (2*CST_VIEW_DISTANCE);
const uint CST_NB_CHUNKS_XZ = CST_NB_CHUNKS_X * CST_NB_CHUNKS_X;

const vec3 CST_LIGHT_DIRECTION = normalize(vec3(-0.7, -1.5, -1.1));
const vec3 CST_LIGHT_DIRECTION_INV = 1 / CST_LIGHT_DIRECTION;
const vec3 CST_LIGHT_AMBIENT = vec3(0.15, 0.3, 0.2);

const vec3 CST_NORMAL_MAP[6] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1),
    vec3(-1, 0, 0),
    vec3(0, -1, 0),
    vec3(0, 0, -1),
};

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 direction_inv;
};

struct Material {
    int type;
    int texture_coords[6];
};

#define TEX_UNIQUE(v) (v), (v), (v), (v), (v), (v)
#define TEX_COLUMN(v, w, z) (v), (w), (v), (v), (z), (v)
#define MATERIAL_EMPTY() Material(0, int[6]( TEX_UNIQUE(0) ))
#define MATERIAL_U(u) Material(1, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_C(v, w, z) Material(1, int[6]( TEX_COLUMN(v, w, z) ))
#define MATERIAL_LOG(i) MATERIAL_C(LOGS_TEX + i*2, TOP_LOGS_TEX + i*2, TOP_LOGS_TEX + i*2)

#define STONE_TEX       0
#define DIRT_TEX        2
#define GRASS_TOP_TEX   4
#define GRASS_SIDE_TEX  6
#define SAND_TEX        8
#define SNOW_TEX        10
#define GRAVEL_TEX      12
#define CACTUS_TOP_TEX  14
#define CACTUS_SIDE_TEX 16
#define CACTUS_BOTT_TEX 18
#define LOGS_TEX        20
#define TOP_LOGS_TEX    32

const Material CST_BLOCK_MATERIALS[] = {
    MATERIAL_EMPTY(),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),                                          // Stone
    MATERIAL_C(GRASS_SIDE_TEX, GRASS_TOP_TEX, DIRT_TEX),            // Grass
    MATERIAL_U(DIRT_TEX),                                           // Dirt
    MATERIAL_U(GRAVEL_TEX),                                         // Gravel
    MATERIAL_U(SAND_TEX),                                           // Sand
    MATERIAL_C(CACTUS_SIDE_TEX, CACTUS_TOP_TEX, CACTUS_BOTT_TEX),   // Cactus
    MATERIAL_U(SNOW_TEX),                                           // Snow
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(LOGS_TEX),
    MATERIAL_LOG(0),
    MATERIAL_LOG(1),
    MATERIAL_LOG(2),
    MATERIAL_LOG(3),
    MATERIAL_LOG(4),
    MATERIAL_LOG(5),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
    MATERIAL_U(STONE_TEX),
};

/* ************************************************************
 * > -1- Variables
 * ************************************************************/
    /* > -A- Inputs */
layout (std430) readonly buffer shader_data {
    uint cl_filled[CST_NB_CHUNKS_XZ][16];
    uint cl_blocks[CST_NB_CHUNKS_XZ][CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
};

uniform VirtualScreen in_uni_screen;
uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform sampler2DArray in_uni_textures;

    /* > -B- Outputs */
layout (binding = 0, rgba32f) uniform image2D out_uni_frame;

    /* > -C- Global Variables */
ivec2 var_cur_chunk = ivec2(-1);

/* ************************************************************
 * > -2- Helpers (abr: "h")
 * ************************************************************/
    /* > -A- Float Operations (abr: "f") */
float h_f_inv_safe(float v) {
    return v == 0.0 ? 1e15 : (1 / v);
}
    /* > -B- Vector Operations (abr: "v") */
float h_v_component_min(vec3 v) {
    return min(min(v.x, v.y), v.z); 
}
float h_v_component_max(vec3 v) {
    return max(max(v.x, v.y), v.z); 
}
vec3 h_v_inv_safe(vec3 v) {
    return vec3(h_f_inv_safe(v.x), h_f_inv_safe(v.y), h_f_inv_safe(v.z));
}
vec3 h_v_inv(vec3 v) {
    // WANING: this entirely rely on GLSL 4.30 (see: 4.7.1 Range and Precision)
    // https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.30.pdf
    // We have the guarantee that a division will lead to (+/-)Inf, which is
    // OK for the usages here and should be slightly faster than the safe
    // version.

    return vec3(1) / v;
}

    /* > -C Array Operations (abr: "a") */
uint h_a_2d_to_1d(ivec2 coords, uint width) {
    return coords.x + coords.y * width;
}
uint h_a_3d_to_1d(ivec3 coords, uint width, uint height) {
    return coords.x + (coords.y + coords.z * height) * width;
}


/* ************************************************************
 * > -3- Section: Ray (abr: "ray")
 * ************************************************************/

vec3 ray_direction(vec2 pixel) {
    return normalize(in_uni_screen.top_left 
        - pixel.x * in_uni_screen.left
        - pixel.y * in_uni_screen.up);
}

Ray ray_make(vec2 pixel) {
    vec3 r_dir = ray_direction(pixel);
    vec3 r_dir_inv = h_v_inv(r_dir);

    return Ray(in_uni_origin, r_dir, r_dir_inv);
}

/* ************************************************************
 * > -3- Section: World
 * ************************************************************/

/* ************************************************************
 * > -4- Section: Chunks Load (abr: "cl")
 * ************************************************************/
    /* > -A- Chunks */
uint cl_value(ivec3 chunk) {
    uint xz = h_a_2d_to_1d(chunk.xz, CST_NB_CHUNKS_X);
    return cl_filled[xz][chunk.y];
}

// Checks if the given point (in chunk referential) is inside the current chunk load
bool cl_is_inside(ivec3 chunk) {
    return chunk.x >= 0 && chunk.x < CST_NB_CHUNKS_X
        && chunk.y >= 0 && chunk.y < 16
        && chunk.z >= 0 && chunk.z < CST_NB_CHUNKS_X;
}

    /* > -B- Blocks */
uint bl_value(ivec3 block) {
    return cl_blocks
        [h_a_2d_to_1d(var_cur_chunk - in_uni_cl_min_coords, CST_NB_CHUNKS_X)]
        [block.x + (block.z + block.y * CST_CHUNK_WIDTH) * CST_CHUNK_WIDTH];
}
bool bl_is_inside(ivec3 block) {
    return block.x >= 0 && block.x < CST_CHUNK_WIDTH
        && block.y >= 0 && block.y < CST_CHUNK_HEIGHT
        && block.z >= 0 && block.z < CST_CHUNK_WIDTH;
}

/* ************************************************************
 * > -5- Section: Intersections
 * ************************************************************/


/* ************************************************************
 * > -6- Section: Ray Tracer
 * ************************************************************/

vec4 sky_color(Ray r) {
    /*
    //vec3 color = vec3(0);
    vec3 color = (cos(r.direction*1.5) + sin(r.origin/7) + vec3(2))/4;
    return vec4(color, 1);
    */

    vec3 color = vec3(0.149, 0.6471, 0.7961);
    float coeff = abs(dot(r.direction, vec3(0, 1, 0))) * 0.2 + 0.8;
    return vec4(color * coeff, 1);
}

#define DRAW_RAY(R, MAX_ITER, FCT_VALID_POS, FCT_GET_VAL, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 out_pos = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 out_side_dist = (_sgn * (out_pos - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    bvec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && FCT_VALID_POS(out_pos); _i++) {\
        uint out_value = FCT_GET_VAL(out_pos);\
        if (out_value != 0) {\
            {BOCK;}\
        }\
        _mask = lessThanEqual(out_side_dist.xyz, min(out_side_dist.yzx, out_side_dist.zxy));\
        out_side_dist += vec3(_mask) * _dt_dist;\
        out_pos += ivec3(vec3(_mask)) * _steps;\
    }

#define DRAW_RAY_2(R, MAX_ITER, FCT_VALID_POS, FCT_GET_VAL, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 out_pos = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 out_side_dist = (_sgn * (out_pos - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    bvec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && FCT_VALID_POS(out_pos); _i++) {\
        uint out_value = FCT_GET_VAL(out_pos);\
        if (out_value != 0) {\
            {BOCK;}\
        }\
        if (out_side_dist.x < out_side_dist.y) {\
            if (out_side_dist.x < out_side_dist.z) {\
                out_side_dist.x += _dt_dist.x;\
                out_pos.x += _steps.x;\
                _mask = bvec3(true, false, false);\
            } else {\
                out_side_dist.z += _dt_dist.z;\
                out_pos.z += _steps.z;\
                _mask = bvec3(false, false, true);\
            }\
        } else {\
            if (out_side_dist.y < out_side_dist.z) {\
                out_side_dist.y += _dt_dist.y;\
                out_pos.y += _steps.y;\
                _mask = bvec3(false, true, false);\
            } else {\
                out_side_dist.z += _dt_dist.z;\
                out_pos.z += _steps.z;\
                _mask = bvec3(false, false, true);\
            }\
        }\
    }

float BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    vec2 t = max(tmin.xx, tmin.yz);
    return max(t.x, t.y);
}

vec2 BBoxRayIntersects(const vec3 boxMin, const vec3 boxMax, const Ray r, out int face) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    int facex = 0;
    int facey = 1;
    int facez = 2;

    if (tbot.x > tbot.x)
        facex = 3;
    if (tbot.y > tbot.y)
        facey = 4;
    if (tbot.z > tbot.z)
        facez = 5;

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    float t1 = tmin.x;
    face = facex;

    if (tmin.y > t1)
    {
        t1 = tmin.y;
        face = facey;
    }

    if (tmin.z > t1)
    {
        t1 = tmin.z;
        face = facez;
    }

    float t2 = min(min(tmax.x, tmax.y), tmax.z);

    return vec2(t1, t2);
}

#define FIND_INTERSECTION(RAY, MAX_CHUNKS, MEGA_BOCK)\
    Ray r_chunk = RAY;\
    r_chunk.origin = RAY.origin * CST_WORLD_TO_LOCAL - vec3(in_uni_cl_min_coords.x, 0, in_uni_cl_min_coords.y);\
    DRAW_RAY(r_chunk, MAX_CHUNKS, cl_is_inside, cl_value, {\
        var_cur_chunk = ivec2(out_pos.xz) + in_uni_cl_min_coords;\
        vec3 world_chunk_pos_min = vec3(var_cur_chunk.x, out_pos.y, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;\
        vec3 world_chunk_pos_max = vec3(var_cur_chunk.x+1, out_pos.y+1, var_cur_chunk.y+1) * CST_LOCAL_TO_WORLD;\
        Ray r_block = RAY;\
        if (_i > 0) {\
            float t = BBoxIntersect(world_chunk_pos_min, world_chunk_pos_max, RAY);\
            r_block.origin += RAY.direction * (t + CST_EPSILON);\
        }\
        r_block.origin -= vec3(var_cur_chunk.x, 0, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;\
        DRAW_RAY(r_block, CST_CHUNK_HEIGHT, bl_is_inside, bl_value, {\
            MEGA_BOCK\
        });\
    });\

float distance_before_next_intersection(Ray ray) {
    FIND_INTERSECTION(ray, CST_NB_CHUNKS_X, {
        // FIXME: return distance to next intersection
        return 0.;
        // FIXME-END
    });
    return 1000.;
}

vec2 bbox_uv(const vec3 boxMin, const vec3 boxMax, const Ray r, float t, int face) {
    vec3 pos = r.origin + r.direction * t;
    vec3 diff = boxMax - boxMin;

    if (face == 0 || face == 3) {
        return vec2((pos.z - boxMin.z) / diff.z, 1 - (pos.y - boxMin.y) / diff.y);
    }

    if (face == 1 || face == 4) {
        return vec2((pos.x - boxMin.x) / diff.x, (pos.z - boxMin.z) / diff.z);
    }

    return vec2((pos.x - boxMin.x) / diff.x, 1 - (pos.y - boxMin.y) / diff.y);
}

vec4 texture_color(int tex, vec2 uv, float t) {
    return textureLod(in_uni_textures, vec3(uv.x, uv.y, float(tex)), t*2);
}

vec3 texture_normal(int texture, vec3 normal, vec2 uv, int face, float t) {
    vec3 tangeant;

    if (face == 2 || face == 5)
        tangeant = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    else
        tangeant = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));

    vec3 b = normalize(cross(normal, tangeant));
    vec4 color = textureLod(in_uni_textures, vec3(uv.x, uv.y, float(texture + 1)), t*2);
    vec3 map_normal = color.xyz * 2 - vec3(1);

    //FIXME mat3 could be precomputed for face
    return mat3(tangeant, b, normal) * map_normal;
}

vec4 lighting(vec4 color, vec3 intersection, vec3 normal) {
    Ray shadow_ray = Ray(intersection, -CST_LIGHT_DIRECTION, -CST_LIGHT_DIRECTION_INV);

    vec3 light_diffuse = CST_LIGHT_AMBIENT;

    if (!CST_SHADOW_ACTIVATED || distance_before_next_intersection(shadow_ray) >= 1000.) {
        light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));
    }

    return vec4(light_diffuse, 1) * color;
}


vec4 cast_ray(Ray ray) {
    FIND_INTERSECTION(ray, uint(-1), {
        vec3 min_pos = out_pos;
        vec3 max_pos;
        vec3 max_pos_offset = vec3(1);

        if (out_value == 1) { // water
            max_pos_offset = vec3(1, 0.9, 1);
        } else if (out_value == 8) { // snow
            max_pos_offset = vec3(1, 0.1, 1);
        }

        max_pos = min_pos + max_pos_offset;

        int face = 0;
        vec2 v = BBoxRayIntersects(min_pos, max_pos, r_block, face);

        if (v.x < v.y)
        {
            vec2 uv = bbox_uv(min_pos, max_pos, r_block, v.x, face);
            if (int(world_chunk_pos_min.x + min_pos.x) == in_uni_highlighted_block.x && int(min_pos.y) == in_uni_highlighted_block.y && int(world_chunk_pos_min.z + min_pos.z) == in_uni_highlighted_block.z
                    && (uv.x < 0.005 || uv.x > 0.995 || uv.y < 0.005 || uv.y > 0.995))
                return vec4(0.5, 0.5, 0.5, 1);

            int tex = CST_BLOCK_MATERIALS[out_value].texture_coords[face];

            vec3 normal = texture_normal(tex, CST_NORMAL_MAP[face], uv, face, v.x);

            vec3 intersection = r_block.origin + r_block.direction * v.x;
            intersection += vec3(var_cur_chunk.x, 0, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;
            intersection += vec3(1) - max_pos_offset;
            intersection += normal * CST_EPSILON;

            vec4 color = texture_color(tex, uv, v.x);
            return lighting(color, intersection, normal);
        }

    });

    return sky_color(ray);
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    Ray ray = ray_make(vec2(pixel));

    vec4 color = cast_ray(ray);

    imageStore(out_uni_frame, pixel, color);
}
