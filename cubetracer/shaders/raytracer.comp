#version 430 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

/* ************************************************************
 * > --1- Constants
 * ************************************************************/
const bool CST_SHADOW_ACTIVATED = <<<CST_SHADOW_ACTIVATED>>>;
const bool CST_SPECULAR_ACTIVATED = false;
const int  CST_TEXTURE_QUALITY_COEFF = <<<CST_TEXTURE_QUALITY_COEFF>>>;

const float CST_SPECULAR_SHININESS = 16;

const float CST_EPSILON = 1e-4;
const uint CST_CHUNK_WIDTH = 16;
const uint CST_CHUNK_HEIGHT = 256;
const vec3 CST_LOCAL_TO_WORLD = vec3(CST_CHUNK_WIDTH);
const vec3 CST_WORLD_TO_LOCAL = 1 / CST_LOCAL_TO_WORLD;
const vec3 CST_BLOCK_COLORS[] = {
    vec3(1, 1, 0),
    vec3(0, 0, 1),
    vec3(0.2, 0.2, 0.2),
    vec3(0, 1, 0),
    vec3(0.7, 0.6, 0.),
    vec3(0.4, 0.4, 0.4),

    vec3(0.8, 0.6, 0.3),
    vec3(0, 0.9, 0),
    vec3(0.9),
    vec3(0, 0.6, 0.1),
};

const uint CST_VIEW_DISTANCE = <<<CST_VIEW_DISTANCE>>>;
const uint CST_NB_CHUNKS_X = (2*CST_VIEW_DISTANCE);
const uint CST_NB_CHUNKS_XZ = CST_NB_CHUNKS_X * CST_NB_CHUNKS_X;

const vec3 CST_LIGHT_DIRECTION = normalize(vec3(-0.7, -1.5, -1.1));
const vec3 CST_LIGHT_DIRECTION_INV = 1 / CST_LIGHT_DIRECTION;
const vec3 CST_LIGHT_AMBIENT = vec3(0.0, 0.0, 0.0);

const uint CST_MAX_ITER_UNCERTAIN_BLOCKS = 32;
const uint CST_MAX_ITER_TRANSPARENT = 16;
const uint CST_MAX_ITER_SHADOW = 16;
const uint CST_MAX_ITER_BLOCK_REFLECTION = 16;
const uint CST_MAX_ITER_WATER_REFLECTION = 64;
const uint CST_MAX_ITER_WATER_REFRACTION = 64;

const vec3 CST_NORMAL_MAP[6] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1),
    vec3(-1, 0, 0),
    vec3(0, -1, 0),
    vec3(0, 0, -1),
};

const uint CST_BLOCK_TYPE_AIR    = 0;
const uint CST_BLOCK_TYPE_WATER  = 1;

const vec3  CST_WATER_TRANSMITTANCE = vec3(0.4, 0.3, 0.1);
const float CST_WATER_IOR = 1.29;

#define CST_USE_FRESNEL true
#define CST_USE_BEER_ATTENUATION true

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 direction_inv;
};

struct Material {
    int type;
    int texture_coords[6];
};

#define TEX_UNIQUE(v) (v), (v), (v), (v), (v), (v)
#define TEX_COLUMN(v, w, z) (v), (w), (v), (v), (z), (v)
#define MATERIAL_EMPTY() Material(0, int[6]( TEX_UNIQUE(0) ))
#define MATERIAL_U(u) Material(1, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_U_NO_NORM(u) Material(2, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_PLANT(u) Material(3, int[6] (TEX_UNIQUE(u)))
#define MATERIAL_FLOWER(i) Material(3, int[6] (TEX_UNIQUE(FLOWER_TEX + i*2)))
#define MATERIAL_C(v, w, z) Material(1, int[6]( TEX_COLUMN(v, w, z) ))
#define MATERIAL_LOG(i) MATERIAL_C(LOGS_TEX + i*2, TOP_LOGS_TEX + i*2, TOP_LOGS_TEX + i*2)
#define MATERIAL_LEAVES(i) MATERIAL_U_NO_NORM(LEAVES_TEX + i)

#define STONE_TEX       0
#define DIRT_TEX        2
#define GRASS_TOP_TEX   4
#define GRASS_SIDE_TEX  6
#define SAND_TEX        8
#define SNOW_TEX        10
#define TALLGRASS_TEX   12
#define GRAVEL_TEX      14
#define CACTUS_TOP_TEX  16
#define CACTUS_SIDE_TEX 18
#define CACTUS_BOTT_TEX 20
#define LOGS_TEX        22
#define TOP_LOGS_TEX    34
#define LEAVES_TEX      46
#define FLOWER_TEX      52

const Material CST_BLOCK_MATERIALS[] = {
    MATERIAL_EMPTY(),
    MATERIAL_EMPTY(),                                               // 1-Water
    MATERIAL_U(STONE_TEX),                                          // 2-Stone
    MATERIAL_C(GRASS_SIDE_TEX, GRASS_TOP_TEX, DIRT_TEX),            // 3-Grass
    MATERIAL_U(DIRT_TEX),                                           // 4-Dirt
    MATERIAL_U(GRAVEL_TEX),                                         // 5-Gravel
    MATERIAL_U(SAND_TEX),                                           // 6-Sand
    MATERIAL_C(CACTUS_SIDE_TEX, CACTUS_TOP_TEX, CACTUS_BOTT_TEX),   // 7-Cactus
    MATERIAL_U(SNOW_TEX),                                           // 8-Snow
    MATERIAL_PLANT(TALLGRASS_TEX),                                  // 9-Tall grass
    MATERIAL_LOG(0),
    MATERIAL_LOG(1),
    MATERIAL_LOG(2),
    MATERIAL_LOG(3),
    MATERIAL_LOG(4),
    MATERIAL_LOG(5),
    MATERIAL_LEAVES(0),
    MATERIAL_LEAVES(1),
    MATERIAL_LEAVES(2),
    MATERIAL_LEAVES(3),
    MATERIAL_LEAVES(4),
    MATERIAL_LEAVES(5),
    MATERIAL_FLOWER(0),
    MATERIAL_FLOWER(1),
    MATERIAL_FLOWER(2),
    MATERIAL_FLOWER(3),
    MATERIAL_FLOWER(4),
    MATERIAL_FLOWER(5),
    MATERIAL_FLOWER(6),
    MATERIAL_FLOWER(7),
    MATERIAL_FLOWER(8),
    MATERIAL_FLOWER(9),
};

const mat3 CST_TEXTURE_NORMAL_TRANSFORMS[6] = {
    mat3( 0,-1, 0,   0, 0,-1,   1, 0, 0),
    mat3( 1, 0, 0,   0, 0,-1,   0, 1, 0),
    mat3(-1, 0, 0,   0,-1, 0,   0, 0, 1),
    mat3( 0, 1, 0,   0, 0,-1,  -1, 0, 0),
    mat3(-1, 0, 0,   0, 0,-1,   0,-1, 0),
    mat3( 1, 0, 0,   0,-1, 0,   0, 0,-1)
};

#define DRAW_RAY_INIT(R)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 block = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 _side_dist = (_sgn * (block - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    vec3 _mask;\
    ivec3 chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
    uint block_type = bl_value(chunk.xz, block);\
    uint _i = 0;\
    bool _is_inside = true;\

#define DRAW_RAY_ITER(BLOCK_TYPE_TO_IGNORE, IGNORE_CURRENT_BLOCK, MAX_ITER, BOCK_ON_NON_INTERSECTION)\
    if (IGNORE_CURRENT_BLOCK)\
        block_type = BLOCK_TYPE_TO_IGNORE;\
    for (;_i < MAX_ITER && block_type == BLOCK_TYPE_TO_IGNORE && _is_inside; _i++) {\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
        chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
        _is_inside = bl_is_inside(block);\
        block_type = bl_value(chunk.xz, block);\
    }\
    if (!(_is_inside && (block_type != BLOCK_TYPE_TO_IGNORE))) \
        {BOCK_ON_NON_INTERSECTION}

#define CAST_RAY(T_BASE, R, BLOCK_TYPE_TO_IGNORE, MAX_BLOCK_ITERATION, WITH_BLOCK_HIGHLIGHTING, BOCK_ON_NON_INTERSECTION, BOCK_ON_UV_COMPUTE, BOCK_ON_WATER_INTERSECTION, BOCK_ON_INTERSECTION)\
    DRAW_RAY_INIT(R);\
    DRAW_RAY_ITER(BLOCK_TYPE_TO_IGNORE, false, MAX_BLOCK_ITERATION, BOCK_ON_NON_INTERSECTION);\
    uint k = 0;\
    do {\
        float t;\
        int face = 0;\
        bool mustComputeIntersection = true;\
        bool mustComputeUv = true;\
        vec2 uv;\
        vec3 normal;\
        /* if uncertain of the box intersection because the box has special shapes, or is transparent,\
        we compute expensive intersections, and continue the ray till we're not sure we can get\
        an intersection with a box*/\
        for (uint j = 0; j < CST_MAX_ITER_UNCERTAIN_BLOCKS && !isIntersectionCertain(block_type); j++) {\
            if (CST_BLOCK_MATERIALS[block_type].type == 3 && plant_intersects(block, CST_BLOCK_MATERIALS[block_type].texture_coords[0], R, t, uv, normal)) {\
                mustComputeUv = false;\
                mustComputeIntersection = false;\
                break;\
            } else if (BBoxRayIntersectsUncertain(block + computeBlockOffsetBot(block_type), block + computeBlockOffsetTop(block_type), R, face, t)) {\
                mustComputeIntersection = false;\
                break;\
            }\
            DRAW_RAY_ITER(BLOCK_TYPE_TO_IGNORE, true, MAX_BLOCK_ITERATION, BOCK_ON_NON_INTERSECTION);\
        }\
        /* need to re-compute the intersection */\
        if (mustComputeIntersection) {\
            t = BBoxRayIntersects(block, block + vec3(1), R, face);\
        }\
        vec3 intersection = R.origin + R.direction * t;\
        if (block_type == CST_BLOCK_TYPE_WATER) {BOCK_ON_WATER_INTERSECTION}\
        if (mustComputeUv)\
            uv = bbox_uv(block, intersection, face);\
        {BOCK_ON_UV_COMPUTE}\
        int tex = CST_BLOCK_MATERIALS[block_type].texture_coords[face];\
        float t_qual = (t + T_BASE) / CST_TEXTURE_QUALITY_COEFF;\
        vec4 color = texture_color(tex, uv, t_qual);\
        if (color.a > 0.5)\
        {\
            switch (CST_BLOCK_MATERIALS[block_type].type)\
            {\
                case 1:\
                    normal = texture_normal(tex, uv, face, t_qual);\
                    break;\
                case 2:\
                    normal = CST_NORMAL_MAP[face];\
                    break;\
                case 3:\
                    normal = texture_normal(tex, uv, t_qual, normal);\
                    break;\
            }\
            {BOCK_ON_INTERSECTION;}\
        }\
        DRAW_RAY_ITER(BLOCK_TYPE_TO_IGNORE, true, MAX_BLOCK_ITERATION, BOCK_ON_NON_INTERSECTION);\
    } while (k++ < CST_MAX_ITER_TRANSPARENT);\
    {BOCK_ON_NON_INTERSECTION}



/* ************************************************************
 * > -1- Variables
 * ************************************************************/
    /* > -A- Inputs */
layout (std430) readonly buffer shader_data {
    uint cl_chunks_mapping[CST_NB_CHUNKS_XZ];
    uint cl_blocks[CST_NB_CHUNKS_XZ][CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
};

uniform VirtualScreen in_uni_screen;
uniform int in_uni_iteration_id;

uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform vec3 in_uni_wind;

uniform sampler2DArray in_uni_textures;

    /* > -B- Outputs */
layout (binding = 0, rgba32f) uniform image2D out_uni_frame;

    /* > -C- Global Variables */

/* ************************************************************
 * > -3- Section: Ray (abr: "ray")
 * ************************************************************/

vec3 ray_direction(const vec2 pixel) {
    return normalize(in_uni_screen.top_left 
        - pixel.x * in_uni_screen.left
        - pixel.y * in_uni_screen.up);
}

Ray ray_make(const vec3 origin, const vec3 direction) {
    const vec3 r_dir_inv = 1 / direction;

    return Ray(origin, direction, r_dir_inv);
}

Ray ray_make_from_pixel(const vec2 pixel) {
    const vec3 origin = in_uni_origin - vec3(in_uni_cl_min_coords.x, 0, in_uni_cl_min_coords.y) * CST_LOCAL_TO_WORLD;
    const vec3 r_dir = ray_direction(pixel);
    const vec3 r_dir_inv = 1 / r_dir;

    return Ray(origin, r_dir, r_dir_inv);
}

/* ************************************************************
 * > -3- Section: Textures
 * ************************************************************/

vec2 bbox_uv(const vec3 boxMin, const vec3 intersection, const int face) {
    const vec3 r = intersection - boxMin;
    return (face == 0 || face == 3) ? vec2(r.z, 1 - r.y)
        : (face == 1 || face == 4) ? vec2(r.x, 1 - r.z)
        : vec2(r.x, 1 - r.y);
}

vec2 texture_coords(const ivec2 pos, const vec2 uv) {
    const vec2 size = vec2(1.0 / 8, 1.0 / 8); // FIXME remove hardcoded width/height
    return (pos + uv) * size;
}

vec4 texture_color(const int tex, const vec2 uv, const float t) {
    return textureLod(in_uni_textures, vec3(uv.x, uv.y, tex), t);
}

vec3 texture_normal(const int tex, const vec2 uv, const int face, const float t) {
    const vec4 color = textureLod(in_uni_textures, vec3(uv.x, uv.y, float(tex + 1)), t);
    const vec3 map_normal = color.rgb * 2 - vec3(1);

    return CST_TEXTURE_NORMAL_TRANSFORMS[face] * map_normal;
}

vec3 texture_normal(const int tex, vec2 uv, const float t, vec3 normal) {
    const vec3 tangeant = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    const vec3 b = normalize(cross(normal, tangeant));

    const vec4 color = textureLod(in_uni_textures, vec3(uv.x, uv.y, float(tex + 1)), t);
    const vec3 map_normal = color.xyz * 2 - vec3(1);

    return mat3(tangeant, b, normal) * map_normal;
}

/* ************************************************************
 * > -4- Section: Chunks/Blocks memory fetching
 * ************************************************************/
bool bl_is_inside(const ivec3 block) {
    return block.x >= 0 && block.x < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH
        && block.y >= 0 && block.y < CST_CHUNK_HEIGHT
        && block.z >= 0 && block.z < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH;
}

uint bl_value(const ivec2 chunk, ivec3 block) {
    block -= ivec3(chunk.x, 0, chunk.y) * ivec3(CST_LOCAL_TO_WORLD);
    const ivec2 a = chunk * ivec2(1, CST_NB_CHUNKS_X);
    const ivec3 b = block.xzy * ivec3(1, CST_CHUNK_WIDTH, CST_CHUNK_WIDTH * CST_CHUNK_WIDTH);
    const uint chunk_idx = cl_chunks_mapping[a.x + a.y];
    return cl_blocks
        [chunk_idx]
        [b.x + b.y + b.z];
}


/* ************************************************************
 * > -6- Section: Ray Tracer
 * ************************************************************/
vec3 sky_color(const Ray r) {
    const vec3 color = vec3(0.149, 0.6471, 0.7961);
    const float coeff = abs(dot(r.direction, vec3(0, 1, 0))) * 0.2 + 0.8;
    return color * coeff;
}

float BBoxRayIntersects(const vec3 boxMin, const vec3 boxMax, const Ray r, out int face) {
    const vec3 tbot = r.direction_inv * (boxMin - r.origin);
    const vec3 ttop = r.direction_inv * (boxMax - r.origin);
    vec3 tmin = min(ttop, tbot);

    float t1 = tmin.x;
    face = 0 + 3 * int(tbot.x < ttop.x);

    if (tmin.y > t1) {
        t1 = tmin.y;
        face = 1 + 3 * int(tbot.y < ttop.y);
    }

    if (tmin.z > t1) {
        t1 = tmin.z;
        face = 2 + 3 * int(tbot.z < ttop.z);
    }

    return t1;
}

bool quadrilater_intersects(int tex, const vec3 pos, const vec3 edge1, const vec3 edge2, const Ray r, out float t, out vec2 uv, out vec3 normal) {
    vec3 h = cross(r.direction, edge2);
    float a = dot(edge1, h);

    if (a > -0.0001 && a < 0.0001) {
        return false;
    }

    float f = 1.0 / a;
    vec3 s = r.origin - pos;
    uv.y = f * dot(s, h);

    if (uv.y < 0.0 || uv.y > 1.0)
        return false;

    vec3 q = cross(s, edge1);
    uv.x = f * dot(r.direction, q);

    if (uv.x < 0.0 || uv.x > 1.0)
        return false;

    uv.y = 1.0 - uv.y;
    t = f * dot(edge2, q);

    normal = cross(edge1, edge2);

    if (dot(normal, r.direction) > 0.0)
        normal = -normal;

    return t > 0.0 && texture_color(tex, uv, t / CST_TEXTURE_QUALITY_COEFF).a > 0.5;
}

bool plant_intersects(const vec3 block_pos, int tex, Ray ray, out float t, out vec2 uv, out vec3 normal) {
    float t2;
    vec2 uv2;
    vec3 normal2;

    bool v1 = quadrilater_intersects(tex, block_pos, in_uni_wind, vec3(1.0, 0.0, 1.0), ray, t, uv, normal);
    bool v2 = quadrilater_intersects(tex, block_pos + vec3(1.0, 0.0, 0.0), in_uni_wind, vec3(-1.0, 0.0, 1.0), ray, t2, uv2, normal2) && (!v1 || t2 < t);

    if (v2)
    {
        uv = uv2;
        t = t2;
        normal = normal2;
        return true;
    }

    return v1;
}

bool BBoxRayIntersectsUncertain(const vec3 boxMin, const vec3 boxMax, const Ray r, out int face, out float t) {
    const vec3 tbot = r.direction_inv * (boxMin - r.origin);
    const vec3 ttop = r.direction_inv * (boxMax - r.origin);

    const ivec3 faces = ivec3(0, 1, 2) + ivec3(3) * ivec3(lessThan(tbot, ttop));

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    float t1 = tmin.x;
    face = faces.x;

    if (tmin.y > t1)
    {
        t1 = tmin.y;
        face = faces.y;
    }

    if (tmin.z > t1)
    {
        t1 = tmin.z;
        face = faces.z;
    }

    const float t2 = min(min(tmax.x, tmax.y), tmax.z);

    if (t1 > 0.0 && t1 < t2) {
        t = t1;
        return true;
    }

    return false;
}


bool isIntersectionCertain(uint block_type) {
    return block_type != 1 
        && block_type != 8
        && block_type != 7
        && block_type != 9
        && CST_BLOCK_MATERIALS[block_type].type != 3
        && CST_BLOCK_MATERIALS[block_type].type != 4;
}

vec3 computeBlockOffsetTop(uint block_type) {
    return float(block_type == 1) * vec3(1, 0.9, 1)
        + float(block_type == 7) * vec3(0.9, 1.0, 0.9)
        + float(block_type == 8) * vec3(1, 0.1, 1);
}
vec3 computeBlockOffsetBot(uint block_type) {
    return float(block_type == 7) * vec3(0.1, 0, 0.1);
}

float distance_before_next_intersection(const Ray ray, const float dist) {
    DRAW_RAY_INIT(ray);
    DRAW_RAY_ITER(CST_BLOCK_TYPE_AIR, false, CST_MAX_ITER_SHADOW, {return 1000;});

    uint k = 0;
    do {
        float t;
        int face = 0;
        bool mustComputeIntersection = true;
        bool mustComputeUv = true;
        vec2 uv;

        vec3 normal;

        for (uint j = 0; j < CST_MAX_ITER_UNCERTAIN_BLOCKS && !isIntersectionCertain(block_type); j++) {
            if ((block_type == 9 || CST_BLOCK_MATERIALS[block_type].type == 4) && plant_intersects(block, CST_BLOCK_MATERIALS[block_type].texture_coords[0], ray, t, uv, normal)) {
                mustComputeUv = false;
                mustComputeIntersection = false;
                break;
            } else if (BBoxRayIntersectsUncertain(block + computeBlockOffsetBot(block_type), block + computeBlockOffsetTop(block_type), ray, face, t)) {
                mustComputeIntersection = false;
                break;
            }

            DRAW_RAY_ITER(CST_BLOCK_TYPE_AIR, true, CST_MAX_ITER_SHADOW, {return 1000;});
        }

        // need to re-compute the intersection
        if (mustComputeIntersection) {
            t = BBoxRayIntersects(block, block + vec3(1), ray, face);
        } 

        vec3 intersection = ray.origin + ray.direction * t;

        if (mustComputeUv)
            uv = bbox_uv(block, intersection, face);

        float t_qual = (t + dist / 3) / CST_TEXTURE_QUALITY_COEFF;
        int tex = CST_BLOCK_MATERIALS[block_type].texture_coords[face];
        vec4 color = texture_color(tex, uv, t_qual);

        if (color.a > 0.5)
            return t;

        DRAW_RAY_ITER(CST_BLOCK_TYPE_AIR, true, CST_MAX_ITER_SHADOW, {return 1000;});
    } while (k++ < CST_MAX_ITER_TRANSPARENT);

    return 1000;
}

vec3 lightingWithoutShadows(vec3 origin, vec3 color, vec3 intersection, vec3 normal) {
    vec3 light_diffuse = CST_LIGHT_AMBIENT;
    light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));

    return light_diffuse * color;
}

vec3 lighting(vec3 origin, vec3 color, vec3 intersection, vec3 normal, float dist) {
    intersection += normal * CST_EPSILON;
    Ray shadow_ray = Ray(intersection, -CST_LIGHT_DIRECTION, -CST_LIGHT_DIRECTION_INV);

    vec3 light_diffuse = CST_LIGHT_AMBIENT;

    if (!CST_SHADOW_ACTIVATED || distance_before_next_intersection(shadow_ray, dist) >= CST_MAX_ITER_SHADOW) {
        light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));

        #if CST_SPECULAR_ACTIVATED
            vec3 h = normalize(CST_LIGHT_DIRECTION + origin - intersection);
            float specular_intensity = pow(max(dot(normal, h), 0.0), CST_SPECULAR_SHININESS);
            light_diffuse += vec3(specular_intensity);
        #endif
    }

    return light_diffuse * color;
}


float fresnel(vec3 incident)
{
    const vec3 normal = vec3(0, -1, 0);

    #if CST_USE_FRESNEL
        const float n1 = 1.;
        const float n2 = CST_WATER_IOR;

        float r0 = (n1 - n2) / (n1 + n2);
        r0 *= r0;

        float x  = 1.0 + dot(normal, incident);
        return clamp(r0 + (1.0 - r0) * x * x * x * x * x, 0, 1);;
    #else
        return 1-clamp(dot(normal, incident), 0, 1);
    #endif
}

vec3 lightingWaterReflection(const vec3 LWR_intersection, const vec3 LWR_incident, const float dist) {
    const Ray ray = ray_make(LWR_intersection, reflect(LWR_incident, vec3(0, 1, 0)));

    CAST_RAY(dist, ray, CST_BLOCK_TYPE_AIR, CST_MAX_ITER_WATER_REFLECTION, false, {
        return sky_color(ray);
    }, {}, { return vec3(1, 0, 0); }, {
        return lightingWithoutShadows(ray.origin, color.rgb, intersection, normal);
    });
}

vec3 lightingWaterRefraction(const vec3 LWR_intersection, const vec3 LWR_incident, const float dist) {
    const Ray ray = ray_make(LWR_intersection, refract(LWR_incident, vec3(0, 1, 0), 1/CST_WATER_IOR));

    CAST_RAY(dist, ray, CST_BLOCK_TYPE_WATER, CST_MAX_ITER_WATER_REFRACTION, false, {
        return vec3(0, 0.1, 0.4);
    }, {}, { return vec3(1, 0, 0); }, {
        vec3 outColor = lightingWithoutShadows(ray.origin, color.rgb, intersection, normal);

        if (CST_USE_BEER_ATTENUATION)
            outColor *= exp(-CST_WATER_TRANSMITTANCE * t);

        return outColor;
    });
}


vec3 lightingWater(const vec3 intersection, const vec3 incident, const float dist) {
    vec3 colorRefract = lightingWaterRefraction(intersection, incident, dist);
    vec3 colorReflect = lightingWaterReflection(intersection, incident, dist);

    const float coeffReflectivity = fresnel(incident);
    return coeffReflectivity * colorReflect + (1-coeffReflectivity) * colorRefract;
}

vec3 cast_ray(const Ray ray) {
    CAST_RAY(0.0, ray, CST_BLOCK_TYPE_AIR, 2 * CST_NB_CHUNKS_X * CST_CHUNK_WIDTH, true, {
        return sky_color(ray);
    }, {
        if (block == in_uni_highlighted_block && (uv.x < 0.005 || uv.x > 0.995 || uv.y < 0.005 || uv.y > 0.995))
            return vec3(0.5);
    }, {
        return lightingWater(intersection, ray.direction, t);
    },{
        return lighting(ray.origin, color.rgb, intersection, normal, t);
    });
}

void main() {
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    const Ray ray = ray_make_from_pixel(vec2(pixel));
    vec4 color = vec4(cast_ray(ray), 1);

    color += imageLoad(out_uni_frame, pixel) * float(in_uni_iteration_id);
    imageStore(out_uni_frame, pixel, color / (in_uni_iteration_id + 1));
}
