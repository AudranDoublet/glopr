#version 430 core
// FIXME: We should implement an `#include` system to split this code into multiple sources

// FIXME: Should be configurable before compilation instead of being hardcoded
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* ************************************************************
 * > --1- Constants
 * ************************************************************/
const float CST_EPSILON = 1e-4;
const uint CST_CHUNK_WIDTH = 16;
const uint CST_CHUNK_HEIGHT = 256;
const vec3 CST_LOCAL_TO_WORLD = vec3(CST_CHUNK_WIDTH);
const vec3 CST_WORLD_TO_LOCAL = 1 / CST_LOCAL_TO_WORLD;
const vec3 CST_BLOCK_COLORS[] = {
    vec3(1, 1, 0),
    vec3(0, 0, 1),
    vec3(0.2, 0.2, 0.2),
    vec3(0, 1, 0),
    vec3(0.7, 0.6, 0.),
    vec3(0.4, 0.4, 0.4),

    vec3(0.8, 0.6, 0.3),
    vec3(0, 0.9, 0),
    vec3(0.9),
    vec3(0, 0.6, 0.1),
};

const uint CST_VIEW_DISTANCE = <<<CST_VIEW_DISTANCE>>>;
const uint CST_NB_CHUNKS_X = (2*CST_VIEW_DISTANCE);
const uint CST_NB_CHUNKS_XZ = CST_NB_CHUNKS_X * CST_NB_CHUNKS_X;

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 direction_inv;
};

/* ************************************************************
 * > -1- Variables
 * ************************************************************/
    /* > -A- Inputs */
layout (std430) readonly buffer shader_data {
    uint cl_filled[CST_NB_CHUNKS_XZ][16];
    uint cl_blocks[CST_NB_CHUNKS_XZ][CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
};

uniform VirtualScreen in_uni_screen;
uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

    /* > -B- Outputs */
layout (binding = 0, rgba32f) uniform image2D out_uni_frame;

    /* > -C- Global Variables */
ivec2 var_cur_chunk = ivec2(-1);

/* ************************************************************
 * > -2- Helpers (abr: "h")
 * ************************************************************/
    /* > -A- Float Operations (abr: "f") */
float h_f_inv_safe(float v) {
    return v == 0.0 ? 1e15 : (1 / v);
}
    /* > -B- Vector Operations (abr: "v") */
float h_v_component_min(vec3 v) {
    return min(min(v.x, v.y), v.z); 
}
float h_v_component_max(vec3 v) {
    return max(max(v.x, v.y), v.z); 
}
vec3 h_v_inv_safe(vec3 v) {
    return vec3(h_f_inv_safe(v.x), h_f_inv_safe(v.y), h_f_inv_safe(v.z));
}
vec3 h_v_inv(vec3 v) {
    // WANING: this entirely rely on GLSL 4.30 (see: 4.7.1 Range and Precision)
    // https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.30.pdf
    // We have the guarantee that a division will lead to (+/-)Inf, which is
    // OK for the usages here and should be slightly faster than the safe
    // version.
    return vec3(1) / v;
}

    /* > -C Array Operations (abr: "a") */
uint h_a_2d_to_1d(ivec2 coords, uint width) {
    return coords.x + coords.y * width;
}
uint h_a_3d_to_1d(ivec3 coords, uint width, uint height) {
    return coords.x + (coords.y + coords.z * height) * width;
}


/* ************************************************************
 * > -3- Section: Ray (abr: "ray")
 * ************************************************************/

vec3 ray_direction(vec2 pixel) {
    return normalize(in_uni_screen.top_left 
        - pixel.x * in_uni_screen.left
        - pixel.y * in_uni_screen.up);
}

Ray ray_make(vec2 pixel) {
    vec3 r_dir = ray_direction(pixel);
    vec3 r_dir_inv = h_v_inv(r_dir);

    return Ray(in_uni_origin, r_dir, r_dir_inv);
}

/* ************************************************************
 * > -3- Section: World
 * ************************************************************/

/* ************************************************************
 * > -4- Section: Chunks Load (abr: "cl")
 * ************************************************************/
    /* > -A- Chunks */
uint cl_value(ivec3 chunk) {
    uint xz = h_a_2d_to_1d(chunk.xz, CST_NB_CHUNKS_X);

    /*
    if (xz >= CST_NB_CHUNKS_XZ || chunk.y >= 16) {
        return 0;
    }
    */
    return cl_filled[xz][chunk.y];
}

// Checks if the given point (in chunk referential) is inside the current chunk load
bool cl_is_inside(ivec3 chunk) {
    return chunk.x >= 0 && chunk.x < CST_NB_CHUNKS_X
        && chunk.y >= 0 && chunk.y < 16
        && chunk.z >= 0 && chunk.z < CST_NB_CHUNKS_X;
}

    /* > -B- Blocks */
uint bl_value(ivec3 block) {
    return cl_blocks
        [h_a_2d_to_1d(var_cur_chunk - in_uni_cl_min_coords, CST_NB_CHUNKS_X)]
        [block.x + (block.z + block.y * CST_CHUNK_WIDTH) * CST_CHUNK_WIDTH];
}
bool bl_is_inside(ivec3 block) {
    return block.x >= 0 && block.x < CST_CHUNK_WIDTH
        && block.y >= 0 && block.y < CST_CHUNK_HEIGHT
        && block.z >= 0 && block.z < CST_CHUNK_WIDTH;
}

/* ************************************************************
 * > -5- Section: Intersections
 * ************************************************************/


/* ************************************************************
 * > -6- Section: Ray Tracer
 * ************************************************************/

vec4 sky_color(Ray r) {
    //return (cos(r.direction) + sin(r.origin) + vec3(2))/4;
    return vec4(vec3(0), 1);
}

#define DRAW_RAY(R, MAX_ITER, FCT_VALID_POS, FCT_GET_VAL, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 out_pos = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 out_side_dist = (_sgn * (out_pos - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    bvec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && FCT_VALID_POS(out_pos); _i++) {\
        uint out_value = FCT_GET_VAL(out_pos);\
        if (out_value != 0) {\
            {BOCK;}\
        }\
        _mask = lessThanEqual(out_side_dist.xyz, min(out_side_dist.yzx, out_side_dist.zxy));\
        out_side_dist += vec3(_mask) * _dt_dist;\
        out_pos += ivec3(vec3(_mask)) * _steps;\
    }

#define DRAW_RAY_2(R, MAX_ITER, FCT_VALID_POS, FCT_GET_VAL, BOCK)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 out_pos = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 out_side_dist = (_sgn * (out_pos - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    bvec3 _mask;\
    uint _i = 0;\
    for (; _i < MAX_ITER && FCT_VALID_POS(out_pos); _i++) {\
        uint out_value = FCT_GET_VAL(out_pos);\
        if (out_value != 0) {\
            {BOCK;}\
            break;\
        }\
        if (out_side_dist.x < out_side_dist.y) {\
            if (out_side_dist.x < out_side_dist.z) {\
                out_side_dist.x += _dt_dist.x;\
                out_pos.x += _steps.x;\
                _mask = bvec3(true, false, false);\
            } else {\
                out_side_dist.z += _dt_dist.z;\
                out_pos.z += _steps.z;\
                _mask = bvec3(false, false, true);\
            }\
        } else {\
            if (out_side_dist.y < out_side_dist.z) {\
                out_side_dist.y += _dt_dist.y;\
                out_pos.y += _steps.y;\
                _mask = bvec3(false, true, false);\
            } else {\
                out_side_dist.z += _dt_dist.z;\
                out_pos.z += _steps.z;\
                _mask = bvec3(false, false, true);\
            }\
        }\
    }

float BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    vec2 t = max(tmin.xx, tmin.yz);
    return max(t.x, t.y);
}

vec4 cast_ray(Ray r) {
    /*
    var_cur_chunk = ivec2(floor(r.origin.xz * CST_WORLD_TO_LOCAL.xz));

    Ray r_block = r;
    r_block.origin -= vec3(var_cur_chunk.x, 0, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;

    DRAW_RAY(r_block, CST_CHUNK_HEIGHT, bl_is_inside, bl_value, {
        return vec4(CST_BLOCK_COLORS[out_value], 1) + 0.00000000000001 * vec4(cl_value(out_pos));
    });
    */

    Ray r_chunk = r;
    r_chunk.origin = r.origin * CST_WORLD_TO_LOCAL - vec3(in_uni_cl_min_coords.x, 0, in_uni_cl_min_coords.y);

    DRAW_RAY(r_chunk, CST_NB_CHUNKS_X*100, cl_is_inside, cl_value, {
        var_cur_chunk = ivec2(out_pos.xz) + in_uni_cl_min_coords;

        vec3 world_chunk_pos_min = vec3(var_cur_chunk.x, out_pos.y, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;
        vec3 world_chunk_pos_max = vec3(var_cur_chunk.x+1, out_pos.y+1, var_cur_chunk.y+1) * CST_LOCAL_TO_WORLD;

        Ray r_block = r;
        float t = BBoxIntersect(world_chunk_pos_min, world_chunk_pos_max, r);

        r_block.origin += r.direction * (t + 0.0001);
        r_block.origin -= vec3(var_cur_chunk.x, 0, var_cur_chunk.y) * CST_LOCAL_TO_WORLD;

        DRAW_RAY(r_block, CST_CHUNK_HEIGHT, bl_is_inside, bl_value, {
            return vec4(CST_BLOCK_COLORS[out_value], 1);
        });
    });

    return sky_color(r);
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    Ray ray = ray_make(vec2(pixel));

    vec4 color = cast_ray(ray);
    color += vec4(in_uni_cl_min_coords * 0.0000001, 0, 0);
    /*
    color += vec3(
            cl_filled[
                h_a_3d_to_1d(ivec3(floor(cl_into_referential(ray.origin))), CST_NB_CHUNKS_X, CST_CHUNK_WIDTH)]);
    */

    imageStore(out_uni_frame, pixel, color);
}
