#version 430 core
// FIXME: We should implement an `#include` system to split this code into multiple sources

// FIXME: Should be configurable before compilation instead of being hardcoded
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

/* ************************************************************
 * > --1- Constants
 * ************************************************************/
const bool CST_SHADOW_ACTIVATED = <<<CST_SHADOW_ACTIVATED>>>;

const uint CST_MAX_ITER_UNCERTAIN_BLOCKS = 32;
const uint CST_MAX_ITER_TRANSPARENT = 16;

const float CST_EPSILON = 1e-4;
const uint CST_CHUNK_WIDTH = 16;
const uint CST_CHUNK_HEIGHT = 256;
const vec3 CST_LOCAL_TO_WORLD = vec3(CST_CHUNK_WIDTH);
const vec3 CST_WORLD_TO_LOCAL = 1 / CST_LOCAL_TO_WORLD;
const vec3 CST_BLOCK_COLORS[] = {
    vec3(1, 1, 0),
    vec3(0, 0, 1),
    vec3(0.2, 0.2, 0.2),
    vec3(0, 1, 0),
    vec3(0.7, 0.6, 0.),
    vec3(0.4, 0.4, 0.4),

    vec3(0.8, 0.6, 0.3),
    vec3(0, 0.9, 0),
    vec3(0.9),
    vec3(0, 0.6, 0.1),
};

const uint CST_VIEW_DISTANCE = <<<CST_VIEW_DISTANCE>>>;
const uint CST_NB_CHUNKS_X = (2*CST_VIEW_DISTANCE);
const uint CST_NB_CHUNKS_XZ = CST_NB_CHUNKS_X * CST_NB_CHUNKS_X;

const vec3 CST_LIGHT_DIRECTION = normalize(vec3(-0.7, -1.5, -1.1));
const vec3 CST_LIGHT_DIRECTION_INV = 1 / CST_LIGHT_DIRECTION;
const vec3 CST_LIGHT_AMBIENT = vec3(0.3, 0.3, 0.3);

const vec3 CST_NORMAL_MAP[6] = {
    vec3(1, 0, 0),
    vec3(0, 1, 0),
    vec3(0, 0, 1),
    vec3(-1, 0, 0),
    vec3(0, -1, 0),
    vec3(0, 0, -1),
};

/* ************************************************************
 * > -0- Types
 * ************************************************************/

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Ray {
    vec3 origin;
    vec3 direction;
    vec3 direction_inv;
};

struct Material {
    int type;
    int texture_coords[6];
};

#define TEX_UNIQUE(v) (v), (v), (v), (v), (v), (v)
#define TEX_COLUMN(v, w, z) (v), (w), (v), (v), (z), (v)
#define MATERIAL_EMPTY() Material(0, int[6]( TEX_UNIQUE(0) ))
#define MATERIAL_U(u) Material(1, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_U_NO_NORM(u) Material(2, int[6]( TEX_UNIQUE(u)) )
#define MATERIAL_C(v, w, z) Material(1, int[6]( TEX_COLUMN(v, w, z) ))
#define MATERIAL_LOG(i) MATERIAL_C(LOGS_TEX + i*2, TOP_LOGS_TEX + i*2, TOP_LOGS_TEX + i*2)
#define MATERIAL_LEAVES(i) MATERIAL_U_NO_NORM(LEAVES_TEX + i)

#define STONE_TEX       0
#define DIRT_TEX        2
#define GRASS_TOP_TEX   4
#define GRASS_SIDE_TEX  6
#define SAND_TEX        8
#define SNOW_TEX        10
#define GRAVEL_TEX      12
#define CACTUS_TOP_TEX  14
#define CACTUS_SIDE_TEX 16
#define CACTUS_BOTT_TEX 18
#define LOGS_TEX        20
#define TOP_LOGS_TEX    32
#define LEAVES_TEX      44

const Material CST_BLOCK_MATERIALS[] = {
    MATERIAL_EMPTY(),
    MATERIAL_U(STONE_TEX),                                          // 1-Water
    MATERIAL_U(STONE_TEX),                                          // 2-Stone
    MATERIAL_C(GRASS_SIDE_TEX, GRASS_TOP_TEX, DIRT_TEX),            // 3-Grass
    MATERIAL_U(DIRT_TEX),                                           // 4-Dirt
    MATERIAL_U(GRAVEL_TEX),                                         // 5-Gravel
    MATERIAL_U(SAND_TEX),                                           // 6-Sand
    MATERIAL_C(CACTUS_SIDE_TEX, CACTUS_TOP_TEX, CACTUS_BOTT_TEX),   // 7-Cactus
    MATERIAL_U(SNOW_TEX),                                           // 8-Snow
    MATERIAL_U(STONE_TEX),
    MATERIAL_LOG(0),
    MATERIAL_LOG(1),
    MATERIAL_LOG(2),
    MATERIAL_LOG(3),
    MATERIAL_LOG(4),
    MATERIAL_LOG(5),
    MATERIAL_LEAVES(0),
    MATERIAL_LEAVES(1),
    MATERIAL_LEAVES(2),
    MATERIAL_LEAVES(3),
    MATERIAL_LEAVES(4),
    MATERIAL_LEAVES(5),
};

/* ************************************************************
 * > -1- Variables
 * ************************************************************/
    /* > -A- Inputs */
layout (std430) readonly buffer shader_data {
    uint cl_filled[CST_NB_CHUNKS_XZ][16];
    uint cl_blocks[CST_NB_CHUNKS_XZ][CST_CHUNK_WIDTH*CST_CHUNK_WIDTH*CST_CHUNK_HEIGHT];
};

uniform VirtualScreen in_uni_screen;
uniform vec3 in_uni_origin; // camera origin
uniform ivec2 in_uni_cl_min_coords; // chunks min coord in 

uniform ivec3 in_uni_highlighted_block;

uniform sampler2DArray in_uni_textures;

    /* > -B- Outputs */
layout (binding = 0, rgba32f) uniform image2D out_uni_frame;

    /* > -C- Global Variables */

/* ************************************************************
 * > -3- Section: Ray (abr: "ray")
 * ************************************************************/

vec3 ray_direction(vec2 pixel) {
    return normalize(in_uni_screen.top_left 
        - pixel.x * in_uni_screen.left
        - pixel.y * in_uni_screen.up);
}

Ray ray_make(vec2 pixel) {
    vec3 origin = in_uni_origin - vec3(in_uni_cl_min_coords.x, 0, in_uni_cl_min_coords.y) * CST_LOCAL_TO_WORLD;
    vec3 r_dir = ray_direction(pixel);
    vec3 r_dir_inv = 1 / r_dir;

    return Ray(origin, r_dir, r_dir_inv);
}

/* ************************************************************
 * > -3- Section: Textures
 * ************************************************************/

vec2 bbox_uv(const vec3 boxMin, const vec3 boxMax, const vec3 diff, const vec3 intersection, int face) {
    if (face == 0 || face == 3) {
        return vec2((intersection.z - boxMin.z) / diff.z, 1 - (intersection.y - boxMin.y) / diff.y);
    }

    if (face == 1 || face == 4) {
        return vec2((intersection.x - boxMin.x) / diff.x, (intersection.z - boxMin.z) / diff.z);
    }

    return vec2((intersection.x - boxMin.x) / diff.x, 1 - (intersection.y - boxMin.y) / diff.y);
}

vec2 texture_coords(ivec2 pos, vec2 uv) {
    vec2 size = vec2(1.0 / 8, 1.0 / 8); // FIXME remove hardcoded width/height

    return vec2(float(pos.x) * size.x, float(pos.y) * size.y) + uv * size;
}

vec4 texture_color(int tex, vec2 uv, float t) {
    return textureLod(in_uni_textures, vec3(uv.x, uv.y, float(tex)), t);
}

vec3 texture_normal(int texture, vec3 normal, vec2 uv, int face, float t) {
    vec3 tangeant;

    if (face == 2 || face == 5)
        tangeant = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
    else
        tangeant = normalize(cross(normal, vec3(0.0, 0.0, 1.0)));

    vec3 b = normalize(cross(normal, tangeant));
    vec4 color = textureLod(in_uni_textures, vec3(uv.x, uv.y, float(texture + 1)), t);
    vec3 map_normal = color.xyz * 2 - vec3(1);

    //FIXME mat3 could be precomputed for face
    return mat3(tangeant, b, normal) * map_normal;
}

/* ************************************************************
 * > -4- Section: Chunks/Blocks memory fetching
 * ************************************************************/
    /* > -A- Chunks */
bool bl_is_inside(ivec3 block) {
    return block.x >= 0 && block.x < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH
        && block.y >= 0 && block.y < CST_CHUNK_HEIGHT
        && block.z >= 0 && block.z < CST_NB_CHUNKS_X * CST_CHUNK_WIDTH;
}


    /* > -B- Blocks */
uint bl_value(ivec2 chunk, ivec3 block) {
    block -= ivec3(chunk.x, 0, chunk.y) * ivec3(CST_LOCAL_TO_WORLD);
    return cl_blocks
        [chunk.x + chunk.y * CST_NB_CHUNKS_X]
        [block.x + (block.z + block.y * CST_CHUNK_WIDTH) * CST_CHUNK_WIDTH];
}


/* ************************************************************
 * > -6- Section: Ray Tracer
 * ************************************************************/

vec4 sky_color(Ray r) {
    vec3 color = vec3(0.149, 0.6471, 0.7961);
    float coeff = abs(dot(r.direction, vec3(0, 1, 0))) * 0.2 + 0.8;
    return vec4(color * coeff, 1);
}

float BBoxRayIntersects(const vec3 boxMin, const vec3 boxMax, const Ray r) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);
    vec3 tmin = min(ttop, tbot);
    return max(max(tmin.x, tmin.y), tmin.z);
}

bool BBoxRayIntersectsUncertain(const vec3 boxMin, const vec3 boxMax, const Ray r, out int face, out float t) {
    vec3 tbot = r.direction_inv * (boxMin - r.origin);
    vec3 ttop = r.direction_inv * (boxMax - r.origin);

    ivec3 faces = ivec3(0, 1, 2) + ivec3(3) * ivec3(lessThan(tbot, ttop));

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    float t1 = tmin.x;
    face = faces.x;

    if (tmin.y > t1)
    {
        t1 = tmin.y;
        face = faces.y;
    }

    if (tmin.z > t1)
    {
        t1 = tmin.z;
        face = faces.z;
    }

    float t2 = min(min(tmax.x, tmax.y), tmax.z);

    if (t1 < t2) {
        t = t1;
        return true;
    }

    return false;
}

#define DRAW_RAY(R, MAX_ITER)\
    vec3 _sgn = sign(R.direction);\
    vec3 _dt_dist = abs(R.direction_inv);\
    ivec3 block = ivec3(floor(R.origin));\
    ivec3 _steps = ivec3(_sgn);\
    vec3 _side_dist = (_sgn * (block - R.origin) + _sgn * 0.5 + 0.5) * _dt_dist;\
    vec3 _mask;\
    ivec3 chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
    uint block_type = bl_value(chunk.xz, block);\
    uint _i = 0;\
    bool _is_inside = true;\
    for (;_i < MAX_ITER && block_type == 0 && _is_inside; _i++) {\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
        chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
        _is_inside = bl_is_inside(block);\
        block_type = bl_value(chunk.xz, block);\
    }\

#define DRAW_RAY_CONTINUE(MAX_ITER)\
    for (;_i < MAX_ITER && _is_inside; _i++) {\
        _mask = vec3(lessThanEqual(_side_dist.xyz, min(_side_dist.yzx, _side_dist.zxy)));\
        _side_dist += _mask * _dt_dist;\
        block += ivec3(_mask) * _steps;\
        chunk = ivec3(floor(block * CST_WORLD_TO_LOCAL));\
        _is_inside = bl_is_inside(block);\
        block_type = bl_value(chunk.xz, block);\
        if (block_type != 0) {\
            break;\
        }\
    }\



uint distance_before_next_intersection(Ray ray) {
    DRAW_RAY(ray, CST_NB_CHUNKS_X);
    return (_i >= CST_NB_CHUNKS_X || block_type == 0 || !_is_inside) ? 1000 : _i;
}

vec4 lighting(vec4 color, vec3 intersection, vec3 normal) {
    intersection += normal * CST_EPSILON;

    Ray shadow_ray = Ray(intersection, -CST_LIGHT_DIRECTION, -CST_LIGHT_DIRECTION_INV);

    vec3 light_diffuse = CST_LIGHT_AMBIENT;

    if (!CST_SHADOW_ACTIVATED || distance_before_next_intersection(shadow_ray) >= CST_NB_CHUNKS_X) {
        light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));
    }

    return vec4(light_diffuse, 1) * color;
}

bool isIntersectionCertain(uint block_type) {
    return block_type != 1 
        && block_type != 8;
}



vec4 cast_ray(Ray ray) {
    DRAW_RAY(ray, 2 * CST_NB_CHUNKS_X * CST_CHUNK_WIDTH);
    if (!_is_inside) {
        return sky_color(ray);
    }

    uint k = 0;
    do {
        vec3 block_offset = vec3(1);
        float t = -1.0;
        int face;

        // if uncertain of the box intersection because the box has special shapes, or is transparent,
        // we compute expensive intersections, and continue the ray till we're not sure we can get
        // an intersection with a box
        if (!isIntersectionCertain(block_type)) {
            for (uint j = 0; j < CST_MAX_ITER_UNCERTAIN_BLOCKS; j++) {
                block_offset = float(block_type == 1) * vec3(1, 0.9, 1)
                    + float(block_type == 8) * vec3(1, 0.1, 1);

                if (BBoxRayIntersectsUncertain(block, block + block_offset, ray, face, t)) {
                    break;
                }

                DRAW_RAY_CONTINUE(2 * CST_NB_CHUNKS_X * CST_CHUNK_WIDTH);
                if (!_is_inside) {
                    return sky_color(ray);
                }

                // if no collision within the allowed range
                if (isIntersectionCertain(block_type)) {
                    block_offset = vec3(1);
                    break;
                }
            }
        }

        // it may happens that we found an intersection with the special block we're on, so there is no
        // need to re-compute the intersection
        if (t < 0.0) {
            t = BBoxRayIntersects(block, block + vec3(1), ray);
            ivec3 faces = ivec3(_mask) * (ivec3(0, 1, 2) + 3 * ivec3(greaterThan(_steps, ivec3(0))));
            face = faces.x + faces.y + faces.z;
        }

        vec3 intersection = ray.origin + ray.direction * t;

        vec2 uv = bbox_uv(block, block + block_offset, block_offset, intersection, face);
        if (block.y == in_uni_highlighted_block.y && block.xz == (in_uni_highlighted_block.xz - in_uni_cl_min_coords * CST_LOCAL_TO_WORLD.xz) && (uv.x < 0.005 || uv.x > 0.995 || uv.y < 0.005 || uv.y > 0.995))
            return vec4(0.5, 0.5, 0.5, 1);

        int tex = CST_BLOCK_MATERIALS[block_type].texture_coords[face];
        float t_qual = t / 10;

        vec3 normal = CST_NORMAL_MAP[face];

        if (CST_BLOCK_MATERIALS[block_type].type == 1)
            normal = texture_normal(tex, normal, uv, face, t_qual);

        vec4 color = texture_color(tex, uv, t_qual);

        if (color.a > 0.5)
            return lighting(color, intersection, normal);

        DRAW_RAY_CONTINUE(2 * CST_NB_CHUNKS_X * CST_CHUNK_WIDTH);
        if (!_is_inside) {
            return sky_color(ray);
        }
        k++;
    } while (k < CST_MAX_ITER_TRANSPARENT);
}


void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    Ray ray = ray_make(vec2(pixel));

    vec4 color = cast_ray(ray);

    imageStore(out_uni_frame, pixel, color);
}
