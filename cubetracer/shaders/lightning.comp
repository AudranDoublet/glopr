vec3 sky_color(const Ray r) {
    const vec3 color = vec3(0.149, 0.6471, 0.7961);
    const float coeff = abs(dot(r.direction, vec3(0, 1, 0))) * 0.2 + 0.8;
    return color * coeff;
}

vec3 lightingWithoutShadows(vec3 origin, vec3 color, vec3 intersection, vec3 normal) {
    vec3 light_diffuse = CST_LIGHT_AMBIENT;
    light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));

    return light_diffuse * color;
}

vec3 lighting(vec3 origin, vec3 color, vec3 intersection, vec3 normal, float dist) {
    intersection += normal * CST_EPSILON;
    Ray shadow_ray = Ray(intersection, -CST_LIGHT_DIRECTION, -CST_LIGHT_DIRECTION_INV);

    vec3 light_diffuse = CST_LIGHT_AMBIENT;

    if (!CST_SHADOW_ACTIVATED || distance_before_next_intersection(shadow_ray, dist) >= CST_MAX_ITER_SHADOW) {
        light_diffuse = max(light_diffuse, dot(normal, -CST_LIGHT_DIRECTION));

        #if CST_SPECULAR_ACTIVATED
            vec3 h = normalize(CST_LIGHT_DIRECTION + origin - intersection);
            float specular_intensity = pow(max(dot(normal, h), 0.0), CST_SPECULAR_SHININESS);
            light_diffuse += vec3(specular_intensity);
        #endif
    }

    return light_diffuse * color;
}

float fresnel(vec3 incident)
{
    const vec3 normal = vec3(0, -1, 0);

    #if CST_USE_FRESNEL
        const float n1 = 1.;
        const float n2 = CST_WATER_IOR;

        float r0 = (n1 - n2) / (n1 + n2);
        r0 *= r0;

        float x  = 1.0 + dot(normal, incident);
        return clamp(r0 + (1.0 - r0) * x * x * x * x * x, 0, 1);;
    #else
        return 1-clamp(dot(normal, incident), 0, 1);
    #endif
}

vec3 lightingWaterReflection(const vec3 LWR_intersection, const vec3 LWR_incident, const float dist) {
    const Ray ray = ray_make(LWR_intersection, reflect(LWR_incident, vec3(0, 1, 0)));

    CAST_RAY(dist, ray, CST_BLOCK_TYPE_AIR, CST_MAX_ITER_WATER_REFLECTION, false, {
        return sky_color(ray);
    }, {}, { return vec3(1, 0, 0); }, {
        return lightingWithoutShadows(ray.origin, color.rgb, intersection, normal);
    });
}

vec3 lightingWaterRefraction(const vec3 LWR_intersection, const vec3 LWR_incident, const float dist) {
    const Ray ray = ray_make(LWR_intersection, refract(LWR_incident, vec3(0, 1, 0), 1/CST_WATER_IOR));

    CAST_RAY(dist, ray, CST_BLOCK_TYPE_WATER, CST_MAX_ITER_WATER_REFRACTION, false, {
        return vec3(0, 0.1, 0.4);
    }, {}, { return vec3(1, 0, 0); }, {
        vec3 outColor = lightingWithoutShadows(ray.origin, color.rgb, intersection, normal);

        if (CST_USE_BEER_ATTENUATION)
            outColor *= exp(-CST_WATER_TRANSMITTANCE * t);

        return outColor;
    });
}


vec3 lightingWater(const vec3 intersection, const vec3 incident, const float dist) {
    vec3 colorRefract = lightingWaterRefraction(intersection, incident, dist);
    vec3 colorReflect = lightingWaterReflection(intersection, incident, dist);

    const float coeffReflectivity = fresnel(incident);
    return coeffReflectivity * colorReflect + (1-coeffReflectivity) * colorRefract;
}

vec3 trace_ray(const Ray ray) {
    CAST_RAY(0.0, ray, CST_BLOCK_TYPE_AIR, 2 * CST_NB_CHUNKS_X * CST_CHUNK_WIDTH, true, {
        return sky_color(ray);
    }, {
        if (block == in_uni_highlighted_block && (uv.x < 0.005 || uv.x > 0.995 || uv.y < 0.005 || uv.y > 0.995))
            return vec3(0.5);
    }, {
        return lightingWater(intersection, ray.direction, t);
    },{
        return lighting(ray.origin, color.rgb, intersection, normal, t);
    });
}
