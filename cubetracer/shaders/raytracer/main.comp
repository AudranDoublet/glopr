#version 430 core

float max_component(vec3 v) {
    return max(max(v.x, v.y), v.z); 
}

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Box {
    vec3 center;
    float radius;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

// Implementation taken from following paper: https://pdfs.semanticscholar.org/c939/dcf21acb355b78c66dfc4b19bc2cfd67cf09.pdf
bool intersect_box(Box box, Ray ray, out float d, out vec3 normal) {
    ray.origin = (ray.origin - box.center);

    float winding = max_component(abs(ray.origin) * (1./box.radius)) < 1.0 ? -1.0 : 1.0;

    vec3 sgn = -sign(ray.direction);

    vec3 distance_to_plane = (
            box.radius * winding * sgn - ray.origin
    ) * (vec3(1.) / ray.direction);


#   define TEST(U, VW)\
        all(lessThan(abs(ray.origin.VW + ray.direction.VW * distance_to_plane.U), vec2(box.radius)))

    bvec3 test = bvec3(TEST(x, yz), TEST(y, zx), TEST(z, xy));

    sgn = test.x
        ? vec3(sgn.x, 0.0, 0.0)
        : (test.y
                ? vec3(0.0, sgn.y, 0.0)
                : vec3(0.0, 0.0, test.z ? sgn.z : 0.0));

#   undef TEST

    d = (sgn.x != 0.0)
        ? distance_to_plane.x
        : ((sgn.y != 0.0)
                ? distance_to_plane.y
                : distance_to_plane.z);

    return (sgn.x != 0.0) || (sgn.y != 0.0) || (sgn.z != 0.0);
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform struct VirtualScreen screen;
uniform vec3 origin;

layout (binding = 0, rgba32f) uniform image2D out_frame;

const struct Box debug_box = Box(vec3(0, 0, 10), 1);

vec3 ray_direction(vec2 pixel) {
    return screen.top_left 
        - pixel.x * screen.left
        - pixel.y * screen.up;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    struct Ray ray = Ray(origin, ray_direction(vec2(pixel)));

    vec4 color = vec4(vec3(0), 1);

    float d;
    vec3 normal;
    if (intersect_box(debug_box, ray, d, normal)) {
        color = vec4(1);
    } 

    imageStore(out_frame, pixel, color);
}
