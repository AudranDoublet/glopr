#version 430 core

float max_component(vec3 v) {
    return max(max(v.x, v.y), v.z); 
}

struct VirtualScreen {
    vec3 top_left;
    vec3 left, up; // normalized and scaled left/up screen axes
};

struct Box {
    vec3 center;
    float radius;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

// Implementation taken from following paper: https://pdfs.semanticscholar.org/c939/dcf21acb355b78c66dfc4b19bc2cfd67cf09.pdf
bool intersect_box_opti(Box box, Ray ray, out float d, out vec3 normal) {
    ray.origin = (ray.origin - box.center);

    //float winding = max_component(abs(ray.origin) * (1./box.radius)) < 1.0 ? -1.0 : 1.0;
    float winding = 1.0;

    vec3 sgn = -sign(ray.direction);

    vec3 distance_to_plane = (
            box.radius * winding * sgn - ray.origin
    ) / ray.direction;

#   define TEST(U, VW)\
        all(lessThan(abs(ray.origin.VW + ray.direction.VW * distance_to_plane.U), vec2(box.radius)))

    bvec3 test = bvec3(TEST(x, yz), TEST(y, zx), TEST(z, xy));

    sgn = test.x
        ? vec3(sgn.x, 0.0, 0.0)
        : (test.y
                ? vec3(0.0, sgn.y, 0.0)
                : vec3(0.0, 0.0, test.z ? sgn.z : 0.0));

#   undef TEST

    d = (sgn.x != 0.0)
        ? distance_to_plane.x
        : ((sgn.y != 0.0)
                ? distance_to_plane.y
                : distance_to_plane.z);

    return (sgn.x != 0.0) || (sgn.y != 0.0) || (sgn.z != 0.0);
}

bool intersect_box(vec3 bounds[2], Ray ray, out float d, out vec3 normal) {
    float tmin, tmax, tymin, tymax, tzmin, tzmax;

    bvec3 ray_dir_sign = bvec3(ray.direction.x < 0, ray.direction.y < 0, ray.direction.z < 0);

    tmin  = (bounds[int(ray_dir_sign.x)].x - ray.origin.x) / ray.direction.x;
    tmax  = (bounds[1-int(ray_dir_sign.x)].x - ray.origin.x) / ray.direction.x;
    tymin = (bounds[int(ray_dir_sign.y)].y - ray.origin.y) / ray.direction.y;
    tymax = (bounds[1-int(ray_dir_sign.y)].y - ray.origin.y) / ray.direction.y;

    if ((tmin > tymax) || (tymin > tmax))
        return false;
    if (tymin > tmin)
        tmin = tymin;
    if (tymax < tmax)
        tmax = tymax;

    tzmin = (bounds[int(ray_dir_sign.z)].z - ray.origin.z) / ray.direction.z;
    tzmax = (bounds[1-int(ray_dir_sign.z)].z - ray.origin.z) / ray.direction.z;

    if ((tmin > tzmax) || (tzmin > tmax))
        return false;
    if (tzmin > tmin)
        tmin = tzmin;
    if (tzmax < tmax)
        tmax = tzmax;

    d = tmin;

    return true;
}

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

uniform struct VirtualScreen screen;
uniform vec3 origin;

layout (binding = 0, rgba32f) uniform image2D out_frame;

const struct Box debug_box = Box(vec3(0, 0, -10), 1);

vec3 ray_direction(vec2 pixel) {
    return screen.top_left 
        - pixel.x * screen.left
        - pixel.y * screen.up;
}

const vec3 bounds[2] = {vec3(0), vec3(1)};

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    struct Ray ray = Ray(origin, ray_direction(vec2(pixel)));

    vec4 color = vec4(vec3(0), 1);

    float d;
    vec3 normal;
    /*
    if (intersect_box_opti(debug_box, ray, d, normal)) {
        color = vec4(1);
    } 
    */
    if (intersect_box(bounds, ray, d, normal)) {
        color = vec4(1);
    }

    imageStore(out_frame, pixel, color);
}
